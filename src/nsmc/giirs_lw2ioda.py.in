#!/usr/bin/env python

#
# (C) Copyright 2019 UCAR
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#

from __future__ import print_function
import sys
import argparse
import numpy as np
from datetime import datetime, timedelta
import netCDF4 as nc
import re
import dateutil.parser

sys.path.append("@SCRIPT_LIB_PATH@")
import ioda_conv_ncio as iconv
from orddicts import DefaultOrderedDict


vName = "longwave_radiance"

locationKeyList = [
    ("latitude", "float"),
    ("longitude", "float"),
    ("datetime", "string")
]

LocMdata = DefaultOrderedDict(lambda: DefaultOrderedDict(dict))
RecMdata = DefaultOrderedDict(lambda: DefaultOrderedDict(dict))
VarMdata = DefaultOrderedDict(lambda: DefaultOrderedDict(dict))
AttrData = DefaultOrderedDict(lambda: DefaultOrderedDict(dict))


class LwRadiance(object):
    def __init__(self, filenames, writer):
        self.filenames = filenames
        self.data = DefaultOrderedDict(lambda: DefaultOrderedDict(dict))
        self.writer = writer
        self._read()

    # The mapping from input variables to ioda variables for IR LW radiance is:
    #
    #   dimensions:
    #      LWchannel -> nvars
    #      LWdetector -> nlocs
    #
    #   global attributes:
    #      'Observing Beginning Date' -> YYYY-MM-DD
    #      'Observing Beginning Time' -> HH:MM:SS
    #      The two above attributes get translated to a single datetime value
    #      which becomes the value for each location in datetime@MetaData.
    #      The seconds value is a float number possibly containing fractional seconds.
    #
    #   variables:
    #      LW_wnum(LWchannel) -> channel_wavenumber@VarMetaData
    #      Number the channels starting with 1 assuming that the order
    #      in variables indexed by LWchannel are sequential channel numbers (1..n).
    #
    #      IRLW_Latitude(LWdetector)  -> latitude@MetaData
    #      IRLW_Longitude(LWdetector) -> longitude@MetaData
    #      IRLW_SolarZenith(LWdetector) -> solar_zenith_angle@MetaData
    #      IRLW_SolarAzimuth(LWdetector) -> solar_azimuth_angle@MetaData
    #      IRLW_SatelliteZenith(LWdetector) -> sensor_zenith_angle@MetaData
    #      IRLW_SatelliteAzimuth(LWdetector) -> sensor_azimuth_angle@MetaData
    #
    #      ES_RealLW(LWchannel, Lwdetector) -> longwave_radiance_#@ObsValue
    #      For now, fabricate the QC marks and error esitmate by setting all
    #      locations to 0 for longwave_radiance_#@PreQC and setting all locations
    #      to 2.0 for longwave_radiance_#@ObsError.

    def _read(self):
        valKey = vName, self.writer.OvalName()
        errKey = vName, self.writer.OerrName()
        qcKey = vName, self.writer.OqcName()

        for f in self.filenames:
            ncd = nc.Dataset(f, 'r')

            # Get the number of locations and channels
            nlocs = ncd.dimensions["LWdetector"].size
            nchans = ncd.dimensions["LWchannel"].size
            self.writer._nlocs = nlocs
            self.writer._nvars = nchans
            self.writer._nrecs = 1

            # Channel metadata associated with longwave radiance
            VarMdata['channel_wavenumber'] = self.writer.FillNcVector(
                                   ncd.variables['LW_wnum'][:], 'float')
            VarMdata['channel_number'] = self.writer.FillNcVector(
                                   np.ma.array(range(1,nchans+1)), 'integer')

            # The file contains a single image with a sub-second scan time. We
            # are currently retaining date-time stamps to the nearest second so
            # for now just grab the beginning scan time and use that for all locations.
            # The variables holding the time offset from 1 Jan, 0000 are problematic
            # since the python datetime package doesn't allow year zero, and it's not
            # clear how days are coverted over several millinnea. The observation 
            # date and time are also in global attributes and appear to line up with
            # the file name.
            obsDate = ncd.getncattr("Observing Beginning Date").split("-")
            obsTime = ncd.getncattr("Observing Beginning Time").split(":")
            obsSeconds = timedelta(seconds=int(round(float(obsTime[2]))))
            obsDateTime = datetime(year=int(obsDate[0]), month=int(obsDate[1]),
                                   day=int(obsDate[2]), hour=int(obsTime[0]),
                                   minute=int(obsTime[1])) + obsSeconds
            obsDtimeString = obsDateTime.strftime("%Y-%m-%dT%H:%M:%SZ")

            # Form a vector nlocs long containing the datetime stamp
            LocMdata['datetime'] = self.writer.FillNcVector(
                                   np.full((nlocs), obsDtimeString), 'datetime')

            # Read in the latitude and longitude associated with the long wave data
            LocMdata['latitude'] = self.writer.FillNcVector(
                                   ncd.variables['IRLW_Latitude'][:], 'float')
            LocMdata['longitude'] = self.writer.FillNcVector(
                                    ncd.variables['IRLW_Longitude'][:], 'float')

            # Read in the instrument meta data associated with the long wave data
            LocMdata['solar_zenith_angle'] = self.writer.FillNcVector(
                                   ncd.variables['IRLW_SolarZenith'][:], 'float')
            LocMdata['solar_azimuth_angle'] = self.writer.FillNcVector(
                                    ncd.variables['IRLW_SolarAzimuth'][:], 'float')
            LocMdata['sensor_zenith_angle'] = self.writer.FillNcVector(
                                   ncd.variables['IRLW_SatelliteZenith'][:], 'float')
            LocMdata['sensor_azimuth_angle'] = self.writer.FillNcVector(
                                    ncd.variables['IRLW_SatelliteAzimuth'][:], 'float')

            # Read in the long wave radiance
            # For now fabricate the QC marks and error estimates
            lwRadiance = ncd.variables['ES_RealLW'][:]
            for ivar in range(nchans):
                varName = "longwave_radiance_%d" % (ivar + 1)
                self.data[(varName, 'ObsValue')] = self.writer.FillNcVector(
                                                   lwRadiance[ivar,:], 'float')
                self.data[(varName, 'PreQC')] = self.writer.FillNcVector(
                                                np.full((nlocs), 0), 'integer')
                self.data[(varName, 'ObsError')] = self.writer.FillNcVector(
                                                   np.full((nlocs), 2.0), 'float')

            ncd.close()


def main():

    parser = argparse.ArgumentParser(
        description=(
            'Read NSMC GIIRS long wave radiance file(s) and convert'
            ' to a concatenated IODA formatted output file.')
    )
    required = parser.add_argument_group(title='required arguments')
    required.add_argument(
        '-i', '--input',
        help="name of giirs input file(s)",
        type=str, nargs='+', required=True)
    required.add_argument(
        '-o', '--output',
        help="name of ioda output file",
        type=str, required=True)
    required.add_argument(
        '-d', '--date',
        help="base date for the center of the window",
        metavar="YYYYMMDDHH", type=str, required=True)
    args = parser.parse_args()
    fdate = datetime.strptime(args.date, '%Y%m%d%H')

    writer = iconv.NcWriter(args.output, [], locationKeyList)

    # Read in the giirs lw radiance
    lwrad = LwRadiance(args.input, writer)

    # Add the 'date_time_string' attribute which sets the reference datetime for
    # the observations.
    AttrData['date_time_string'] = fdate.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Write the obs data and meta data into the ioda file
    #(ObsVars, RecMdata, LocMdata, VarMdata) = writer.ExtractObsData(lwrad.data)
    writer.BuildNetcdf(lwrad.data, RecMdata, LocMdata, VarMdata, AttrData)


if __name__ == '__main__':
    main()
